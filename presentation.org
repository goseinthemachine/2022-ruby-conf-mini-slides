#+AUTHOR: Cameron Gose
#+TITLE: Game from Start to Published!
#+OPTIONS: timestamp:nil toc:nil
#+REVEAL_PLUGINS: (highlight notes)
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_HIGHLIGHT_CSS: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/windows-high-contrast.min.css

#+REVEAL_REVEAL_JS_VERSION: 4

* Introduction


* DragonRuby Game Toolkit
#+BEGIN_NOTES
First of all this is not a typo. DragonRuby is one word
#+END_NOTES
** Ruby
#+BEGIN_NOTES
It implements the standard Ruby language spec. DragonRuby is Ruby 2.x compatible, according to the documentation
#+END_NOTES
** Runtime
#+BEGIN_NOTES
DragonRuby is a multilevel cross-platform runtime. It can target PC, Mac, Linux, Raspberry Pi, WASM, iOS, Android, Nintendo Switch, Playstation, XBox, and VR on the Oculus Quest
#+END_NOTES

** Game Toolkit (GTK)
#+BEGIN_NOTES
DragonRuby GTK is a self contained 2D game engine. Where you don't need to learn a UI to use. It does have some 3D capabilities though.
#+END_NOTES

* Requirements
#+BEGIN_NOTES
3 things are really needed to run the GTK. Bring your own editor that supports Ruby
The DragonRuby GTK. It comes in a zipped folder so you just need to unzip it
Need a Linux,Mac,PC or a Raspberry Pi
#+END_NOTES
- BYOE
- DragonRuby GTK
- Linux/MacOS/Raspberry Pi/Windows

* How do you get it
#+BEGIN_NOTES
[[https://dragonruby.itch.io/dragonruby-gtk][itch.io]]
[[https://dragonruby.org/toolkit/game][DragonRuby.org]]
#+END_NOTES
* Initial Setup

- clone repo https://github.com/goseinthemachine/2022-ruby-conf-workshop
- go into the folder
- In the terminal run the following
#+begin_src bash
# For Mac or Linux
./dragonruby
# For Windows
dragonruby
#+end_src
* Let's Publish
#+BEGIN_NOTES
After completing Hello world it is now time to publish to itch.io.
Itch.io is a platform for selling and finding games and other digital content
DragonRuby GTK makes it fairly simple to publish games.
The first publish takes a little bit of work but after the initial setup every publish afterwards is super easy.
So we'll need to go to itch.io
Create an account if you don't have one already.
Now Let's login
Go to this link [[https://dragonruby.org/toolkit/game][New Game Link]]
Fill out the form keep note of the slug added to the game url. We'll need that to update the game metadata
#+END_NOTES
- Go to [[https://itch.io][itch.io]]
- Create an account if you haven't already
** Create the Landing Page
- Go to [[https://itch.io/game/new]]
- Add a title
- Add the project url
- Kind of project change to HTML
** Update Game Metadata
#+BEGIN_NOTES
In mygame/metadata/game_metadata insert something like the following but insert in your values
#+END_NOTES
#+begin_src text
devid=your_itch_io_user_name
devtitle=Your Name
gameid=ruby_conf_mini
gametitle=Ruby Conf Mini Workshop
version=0.1
#+end_src
** Building your game
#+BEGIN_NOTES
We'll be running the dragonruby-publish command
This command needs to be ran in the root of the cloned folder
mygame is the name of the folder to package up which will be mygame in our example
This will build all the executables and put them in a build folder in the root of DragonRuby
#+END_NOTES
#+begin_src bash
# Mac and Linux
./dragonruby-publish --only-package mygame
# Windows
dragonruby-publish --only-package mygame
#+end_src
* The Basics
#+BEGIN_NOTES
We're going to clear out the hello world example and setup the basic game loop
#+END_NOTES
** The Loop
#+BEGIN_NOTES
Every game has a loop that continuously loops over 3 functions. We'll handle user input, update the game state, then render to the screen
We'll create a function in our game for each part of the basic game loop
#+END_NOTES
- Handling Input
- Updating and Calculating Game State
- Rendering to the Screen
** The Loop
Clear main.rb and add the following
#+ATTR_REVEAL: :code_attribs data-line-numbers="1-3|5-9|11-15|17-21"
#+begin_src ruby
def handle_input args

end

# Functions that update game state will go here

def update args

end

# Functions that will render to the screen will go here

def render args

end

def tick args
  handle_input args
  update args
  render args
end
#+end_src

** Handle Input
#+ATTR_REVEAL: :code_attribs data-line-numbers="1-3"
#+begin_src ruby
def handle_input args
  #Code for handling user input will go here
end
#+end_src

** Update
#+BEGIN_NOTES
This function will be used to call other functions that will
update or calculate game state
#+END_NOTES
#+ATTR_REVEAL: :code_attribs data-line-numbers="1-3"
#+begin_src ruby
def update args
  #functions that update game state will go here
end
#+end_src
** Rendering to the screen
#+BEGIN_NOTES
This function will be used to call other render functions
to draw to the game window
#+END_NOTES
#+ATTR_REVEAL: :code_attribs data-line-numbers="1-3"
#+begin_src ruby
def render args
  # Code for rendering will occur here
end
#+end_src
** Tick
#+BEGIN_NOTES
We have these 3 functions now where do we put them?
In DragonRuby GTK there is a function that it looks for in main.rb
That is the tick function
The tick function is important it is called 60 times a second
This ensures a smooth framerate so animations looks smooth
#+END_NOTES
#+BEGIN_NOTES
We'll put the handle_input, render and update functions within tick
Each of these steps occur every time tick is called and each time that
happens the game check for user input, figures out what is going on, then
draws everything to the screen again. This happens every tick 60 times a second.
#+END_NOTES

#+ATTR_REVEAL: :code_attribs data-line-numbers="1-5"
#+begin_src ruby
def tick args # Will contain the GTK environment
  handle_input args
  update args
  render args
end
#+end_src
* Setting up the scene
#+BEGIN_NOTES
Now that we have the basics of the game loop defined in our code we can now start to build the game.
Today we will be building the classic arcade game of snake. In the classic game the snake moves along a grid.
Lets draw that grid.
#+END_NOTES
** Drawing the Grid
#+BEGIN_NOTES
To draw the grid we need to draw lines vertically along the x-axis and horizontally along the y-axis
#+END_NOTES
*** Setting the Grid Size
#+BEGIN_NOTES
We need to define how far the grids should be spaced apart. At the top of the file create a constant to hold GRID SIZE to be equal to 20.
We'll be using GRID_SIZE to set the height and width of each square on the grid.
#+END_NOTES
#+ATTR_REVEAL: :code_attribs data-line-numbers="1|9-10|12-13"
#+BEGIN_SRC ruby
GRID_SIZE = 20

def handle_input args
end

def update args
end

def render_grid args
end

def render args
  render_grid args
end

def tick args
  handle_input args
  update args
  render args
end
#+END_SRC
*** Drawing lines along the X-Axis
#+BEGIN_NOTES
In render grid we are going to add in some code to draw along the x direction.
args.grid.x contains the width of the game window which in our case is 1080
First we'll determine how many lines we need to draw along the x-axis before drawing
DragonRuby GTK provide a nice way to draw lines
args.outputs has a collection call lines. If we append to the lines collection a hash that contains x, y, x2, y2 values
We can draw a line to the screen
#+END_NOTES
#+ATTR_REVEAL: :code_attribs data-line-numbers="9,20|10|12,19|13-18"
#+begin_src ruby
GRID_SIZE = 20

def handle_input args
end

def update args
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE

  x_axis.each_with_index do |x|
        args.outputs.lines << {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end
end

def render args
  render_grid args
end

def tick args
  handle_input args
  update args
  render args
end

#+end_src
*** Drawing lines along the Y-Axis
#+ATTR_REVEAL: :code_attribs data-line-numbers="11|22-28"
#+begin_src ruby
GRID_SIZE = 20

def handle_input args
end

def update args
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE

  x_axis.each_with_index do |x|
    args.outputs.lines << {
      x: x * GRID_SIZE,
      y: 0,
      x2: x * GRID_SIZE,
      y2: args.grid.h
    }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines << {
      x: 0,
      y: y * GRID_SIZE,
      x2: args.grid.w,
      y2: y * GRID_SIZE
    }
  end
end

def render args
  render_grid args
end

def tick args
  handle_input args
  update args
  render args
end

#+end_src

** Drawing the head of the snake
*** Setting up defaults
#+ATTR_REVEAL: :code_attribs data-line-numbers="37,48|38-47|51"
#+begin_src ruby
GRID_SIZE = 20

def handle_input args
end

def update args
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render args
  render_grid args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
*** Rendering the Snake
#+ATTR_REVEAL: :code_attribs data-line-numbers="33-35|39"
#+begin_src ruby
GRID_SIZE = 20

def handle_input args
end

def update args
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render args
  render_grid args
  render_snake args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
* Adding Movement
** Handling player input
#+ATTR_REVEAL: :code_attribs data-line-numbers="3,16|4,5|7-15"
#+begin_src ruby
GRID_SIZE = 20

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def update args
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render args
  render_grid args
  render_snake args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Updating the Snake's Position
#+BEGIN_NOTES
We'll set the speed constant to 10. We'll use this to slow down the movement.
Next we'll create a function to update position of the head of the snake
Then we'll call that function within the update function
#+END_NOTES
#+ATTR_REVEAL: :code_attribs data-line-numbers="2|19,34|20-21|22-31|32-33|36-40"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render args
  render_grid args
  render_snake args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
* Setting Boundaries
** Rendering the walls
#+ATTR_REVEAL: :code_attribs data-line-numbers="81|92-98|99-105|106-112|113-119|70-73|75,78"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render args
  render_grid args
  render_snake args
  render_walls args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src

** Get the walls to stop the snake
#+ATTR_REVEAL: :code_attribs data-line-numbers="36,45|37,38|39,44|40-43|47,50"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render args
  render_grid args
  render_snake args
  render_walls args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src

* Scoring
** Generating a collectable
#+ATTR_REVEAL: :code_attribs data-line-numbers="47,61|48,60|49,50|51-59|63,67,69"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 2).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 2).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Rendering the collectable
#+ATTR_REVEAL: :code_attribs data-line-numbers="104-106|108,112,113"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Collecting
#+ATTR_REVEAL: :code_attribs data-line-numbers="47,52|48|49,51|50|70,74,77"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }
  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Rendering Score
#+ATTR_REVEAL: :code_attribs data-line-numbers="133|174|47,51,53|117,123|118-122|125,130,131"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << {
    x: args.grid.left.shift_right(2 * GRID_SIZE),
    y: args.grid.top.shift_down(2 * GRID_SIZE),
    text: "Score: #{args.state.score}"
  }
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src

* Adding Sound
** Trigger a sound when collecting
- Find a sound you like
- itch.io is a good resource
- Add sound to sounds folder located in mygame folder
** Update function to trigger sound
#+ATTR_REVEAL: :code_attribs data-line-numbers="47,52,54"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << args.state.head
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
* Adding the Snake Body
** Adding the snake body
*** Add initial state to defaults
#+ATTR_REVEAL: :code_attribs data-line-numbers="192"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
*** Increase the body size
#+ATTR_REVEAL: :code_attribs data-line-numbers="47,64|48,49|50|51-59|61,62|63"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right 
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def grow_body args
  segment = args.state.body.any? args.state.body.last.clone :
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
*** Update Collect Collision
#+ATTR_REVEAL: :code_attribs data-line-numbers="66,72,74"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right 
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src

*** Render the body
#+ATTR_REVEAL: :code_attribs data-line-numbers="125-127"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head

  if inputs.left
    head.direction = :left
  elsif inputs.right 
    head.direction = :right
  elsif inputs.up
    head.direction = :up
  elsif inputs.down
    head.direction = :down
  end
end

def move_snake args
  head = args.state.head
  vector = { x: 0, y: 0 }
  case head.direction
  when :right
    vector.x = 1
  when :left
    vector.x = -1
  when :down
    vector.y = -1
  when :up
    vector.y = 1
  end
  head.x += GRID_SIZE * vector.x
  head.y += GRID_SIZE * vector.y
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Refactoring Snake Movement
*** Update handle input
#+ATTR_REVEAL: :code_attribs data-line-numbers="4,19|7,18|8|9|11|13|15"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head
  if args.tick_count.mod_zero? SPEED
    head.previous_direction = head.direction
    if inputs.left && head.previous_direction != :right
      head.direction = :left
    elsif inputs.right && head.previous_direction != :left
      head.direction = :right
    elsif inputs.up && head.previous_direction != :down
      head.direction = :up
    elsif inputs.down && head.previous_direction != :up
      head.direction = :down
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end

end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
*** Update Snake Movement
#+ATTR_REVEAL: :code_attribs data-line-numbers="21,40|22|23,39|24|25|27|37,38"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head
  if args.tick_count.mod_zero? SPEED
    head.previous_direction = head.direction
    if inputs.left && head.previous_direction != :right
      head.direction = :left
    elsif inputs.right && head.previous_direction != :left
      head.direction = :right
    elsif inputs.up && head.previous_direction != :down
      head.direction = :up
    elsif inputs.down && head.previous_direction != :up
      head.direction = :down
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Colliding with self
*** Create function to handle body collision
#+ATTR_REVEAL: :code_attribs data-line-numbers="53-57|104,109,112"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head
  if args.tick_count.mod_zero? SPEED
    head.previous_direction = head.direction
    if inputs.left && head.previous_direction != :right
      head.direction = :left
    elsif inputs.right && head.previous_direction != :left
      head.direction = :right
    elsif inputs.up && head.previous_direction != :down
      head.direction = :up
    elsif inputs.down && head.previous_direction != :up
      head.direction = :down
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    head.x = head.x
      .clamp(walls.left.right, walls.right.left - GRID_SIZE)
    head.y = head.y
      .clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
  end
end

def handle_body_collision args
  if args.state.body.any_intersect_rect? args.state.head
    p "COLLIDED WITH BODY"
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    handle_body_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src

* Adding Game Over
** Adding Game State
#+ATTR_REVEAL: :code_attribs data-line-numbers="206"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head
  if args.tick_count.mod_zero? SPEED
    head.previous_direction = head.direction
    if inputs.left && head.previous_direction != :right
      head.direction = :left
    elsif inputs.right && head.previous_direction != :left
      head.direction = :right
    elsif inputs.up && head.previous_direction != :down
      head.direction = :up
    elsif inputs.down && head.previous_direction != :up
      head.direction = :down
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    # head.x = head.x.clamp(walls.left.right, walls.right.left - GRID_SIZE)
    # head.y = head.y.clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
    args.state.game_state = :game_over
  end
end

def handle_body_collision args
  if args.state.body.any_intersect_rect? args.state.head
    # p "COLLIDED WITH BODY"
    args.state.game_state = :game_over
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    handle_body_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
  args.state.game_state ||= :in_play
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Setting Game Over Conditions
#+ATTR_REVEAL: :code_attribs data-line-numbers="53-57|109"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  head = args.state.head
  if args.tick_count.mod_zero? SPEED
    head.previous_direction = head.direction
    if inputs.left && head.previous_direction != :right
      head.direction = :left
    elsif inputs.right && head.previous_direction != :left
      head.direction = :right
    elsif inputs.up && head.previous_direction != :down
      head.direction = :up
    elsif inputs.down && head.previous_direction != :up
      head.direction = :down
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    # head.x = head.x.clamp(walls.left.right, walls.right.left - GRID_SIZE)
    # head.y = head.y.clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
    args.state.game_state = :game_over
  end
end

def handle_body_collision args
  if args.state.body.any_intersect_rect? args.state.head
    # p "COLLIDED WITH BODY"
    args.state.game_state = :game_over
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    handle_body_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render args
  render_grid args
  render_snake args
  render_walls args
  render_collectable args
  render_score args
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
  args.state.game_state ||= :in_play
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Creating the Game over screen
#+ATTR_REVEAL: :code_attribs data-line-numbers="162|163-169|170-176|177-183|187-189,195"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  if args.state.game_state == :game_over
    if inputs.keyboard.key_down.escape
      $gtk.reset_next_tick
    end
  else
    head = args.state.head
    if args.tick_count.mod_zero? SPEED
      head.previous_direction = head.direction
      if inputs.left && head.previous_direction != :right
        head.direction = :left
      elsif inputs.right && head.previous_direction != :left
        head.direction = :right
      elsif inputs.up && head.previous_direction != :down
        head.direction = :up
      elsif inputs.down && head.previous_direction != :up
        head.direction = :down
      end
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    # head.x = head.x.clamp(walls.left.right, walls.right.left - GRID_SIZE)
    # head.y = head.y.clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
    args.state.game_state = :game_over
  end
end

def handle_body_collision args
  if args.state.body.any_intersect_rect? args.state.head
    # p "COLLIDED WITH BODY"
    args.state.game_state = :game_over
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  return if args.state.game_state == :game_over
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    handle_body_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render_game_over args
  args.outputs.labels << {
    x: args.grid.w / 2,
    y: (args.grid.h / 2).shift_up(16),
    text: "GAME OVER!",
    size_enum: 10,
    alignment_enum: 1
  }
  args.outputs.labels << {
    x: args.grid.w / 2,
    y: (args.grid.h / 2).shift_down(24),
    text: "Final Score was #{args.state.score} points!",
    size_enum: 1,
    alignment_enum: 1
  }
  args.outputs.labels << {
    x: args.grid.w / 2,
    y: (args.grid.h / 2).shift_down(48),
    text: "Press Escape to try again",
    size_enum: 0,
    alignment_enum: 1
  }
end

def render args
  if args.state.game_state == :game_over
    render_game_over args
  else
    render_grid args
    render_snake args
    render_walls args
    render_collectable args
    render_score args
  end
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
  args.state.game_state ||= :in_play
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
** Reset Game
#+ATTR_REVEAL: :code_attribs data-line-numbers="6-10,24"
#+begin_src ruby
GRID_SIZE = 20
SPEED = 10

def handle_input args
  inputs = args.inputs
  if args.state.game_state == :game_over
    if inputs.keyboard.key_down.escape
      $gtk.reset_next_tick
    end
  else
    head = args.state.head
    if args.tick_count.mod_zero? SPEED
      head.previous_direction = head.direction
      if inputs.left && head.previous_direction != :right
        head.direction = :left
      elsif inputs.right && head.previous_direction != :left
        head.direction = :right
      elsif inputs.up && head.previous_direction != :down
        head.direction = :up
      elsif inputs.down && head.previous_direction != :up
        head.direction = :down
      end
    end
  end
end

def move_snake args
  snake = [args.state.head, *args.state.body]
  snake.each_with_index do |segment, index|
    segment.previous_direction = segment.direction unless index == 0
    segment.direction = snake[index - 1].previous_direction unless index == 0
    vector = { x: 0, y: 0 }
    case segment.direction
    when :right
      vector.x = 1
    when :left
      vector.x = -1
    when :down
      vector.y = -1
    when :up
      vector.y = 1
    end
    segment.x += GRID_SIZE * vector.x
    segment.y += GRID_SIZE * vector.y
  end
end

def handle_boundary_collision args
  walls = args.state.walls
  head = args.state.head
  if [walls.left, walls.right, walls.top, walls.bottom].any_intersect_rect?  args.state.head
    # head.x = head.x.clamp(walls.left.right, walls.right.left - GRID_SIZE)
    # head.y = head.y.clamp(walls.bottom.top, walls.top.bottom - GRID_SIZE)
    args.state.game_state = :game_over
  end
end

def handle_body_collision args
  if args.state.body.any_intersect_rect? args.state.head
    # p "COLLIDED WITH BODY"
    args.state.game_state = :game_over
  end
end

def grow_body args
  segment = args.state.body.last.clone ||
    args.state.head.clone
  vector = { x: 0, y: 0 }
  if segment.direction == :right
    vector.x = -1
  elsif segment.direction == :left
    vector.x = 1
  elsif segment.direction == :down
    vector.y = 1
  elsif segment.direction == :up
    vector.y = -1
  end

  segment.x += (GRID_SIZE * vector.x)
  segment.y += (GRID_SIZE * vector.y)
  args.state.body << segment
end

def handle_collectable_collision args
  return if args.state.collectable.nil?
  if args.state.collectable.intersect_rect? args.state.head
    args.state.collectable = nil
    args.state.score += 1
    args.outputs.sounds << "sounds/collect.wav"
    grow_body args
  end
end

def spawn_collectable args
  if args.state.collectable.nil?
    x_rand = ((args.grid.w / GRID_SIZE) - 1).randomize(:ratio).ceil
    y_rand = ((args.grid.h / GRID_SIZE) - 1).randomize(:ratio).ceil
    args.state.collectable = {
      x: x_rand * GRID_SIZE,
      y: y_rand * GRID_SIZE,
      h: GRID_SIZE,
      w: GRID_SIZE,
      r: 233,
      g: 23,
      b: 23
    }
  end
end

def update args
  return if args.state.game_state == :game_over
  if args.tick_count.mod_zero? SPEED
    move_snake args
    handle_boundary_collision args
    handle_collectable_collision args
    handle_body_collision args
    spawn_collectable args
  end
end

def render_grid args
  x_axis = args.grid.w / GRID_SIZE
  y_axis = args.grid.h / GRID_SIZE
  x_axis.each_with_index do |x|
    args.outputs.lines <<
        {
          x: x * GRID_SIZE,
          y: 0,
          x2: x * GRID_SIZE,
          y2: args.grid.h
        }
  end

  y_axis.each_with_index do |y|
    args.outputs.lines <<
      {
        x: 0,
        y: y * GRID_SIZE,
        x2: args.grid.w,
        y2: y * GRID_SIZE
      }
  end
end

def render_snake args
  args.outputs.solids << [args.state.head, *args.state.body]
end

def render_walls args
  walls = args.state.walls
  args.outputs.solids << [walls.left, walls.right, walls.top, walls.bottom]
end

def render_collectable args
  args.outputs.solids << args.state.collectable
end

def render_score args
  args.outputs.labels << { x: args.grid.left.shift_right(2 * GRID_SIZE), y: args.grid.top.shift_down(2 * GRID_SIZE), text: "Score: #{args.state.score}"}
end

def render_game_over args
  args.outputs.labels << {
    x: args.grid.w / 2,
    y: (args.grid.h / 2).shift_up(16),
    text: "GAME OVER!",
    size_enum: 10,
    alignment_enum: 1
  }
  args.outputs.labels << {
    x: args.grid.w / 2,
    y: (args.grid.h / 2).shift_down(24),
    text: "Final Score was #{args.state.score} points!",
    size_enum: 1,
    alignment_enum: 1
  }
  args.outputs.labels << {
    x: args.grid.w / 2,
    y: (args.grid.h / 2).shift_down(48),
    text: "Press Escape to try again",
    size_enum: 0,
    alignment_enum: 1
  }
end

def render args
  if args.state.game_state == :game_over
    render_game_over args
  else
    render_grid args
    render_snake args
    render_walls args
    render_collectable args
    render_score args
  end
end

def defaults args
  args.state.head ||=
  {
    x: args.grid.w / 2,
    y: args.grid.h / 2,
    w: GRID_SIZE,
    h: GRID_SIZE,
    r: 23,
    g: 245,
    b: 23,
  }

  args.state.walls.left ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.right ||= {
    x: args.grid.right - GRID_SIZE,
    y: args.grid.bottom,
    h: args.grid.h,
    w: GRID_SIZE,
    r: 12, g: 33, b: 245
  }
  args.state.walls.top ||= {
    x: args.grid.left,
    y: args.grid.top - GRID_SIZE,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }
  args.state.walls.bottom ||= {
    x: args.grid.left,
    y: args.grid.bottom,
    h: GRID_SIZE,
    w: args.grid.w,
    r: 12, g: 33, b: 245
  }

  args.state.score ||= 0
  args.state.body ||= []
  args.state.game_state ||= :in_play
end

def tick args
  defaults args
  handle_input args
  update args
  render args
end
#+end_src
* Publish!
#+begin_src bash
# Mac OS and Linux
./dragonruby-publish
# Windows
dragonruby-publish
#+end_src
* Now What?
** Community
[[http://discord.dragonruby.org/][DragonRuby Discord]]
** Resources
- Documentation
- Samples
** Explore!
